// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_NIL_XIT_FBS_H_
#define FLATBUFFERS_GENERATED_MESSAGE_NIL_XIT_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace nil {
namespace xit {
namespace fbs {

struct UniqueFrameInfoRequest;
struct UniqueFrameInfoRequestBuilder;
struct UniqueFrameInfoRequestT;

struct TaggedFrameInfoRequest;
struct TaggedFrameInfoRequestBuilder;
struct TaggedFrameInfoRequestT;

struct UniqueFrameInfoResponse;
struct UniqueFrameInfoResponseBuilder;
struct UniqueFrameInfoResponseT;

struct TaggedFrameInfoResponse;
struct TaggedFrameInfoResponseBuilder;
struct TaggedFrameInfoResponseT;

struct FileRequest;
struct FileRequestBuilder;
struct FileRequestT;

struct FileAliasRequest;
struct FileAliasRequestBuilder;
struct FileAliasRequestT;

struct FileInfo;
struct FileInfoBuilder;
struct FileInfoT;

struct FileResponse;
struct FileResponseBuilder;
struct FileResponseT;

struct FileAlias;
struct FileAliasBuilder;
struct FileAliasT;

struct FileAliasResponse;
struct FileAliasResponseBuilder;
struct FileAliasResponseT;

struct FrameCache;
struct FrameCacheBuilder;
struct FrameCacheT;

struct UniqueFrameLoaded;
struct UniqueFrameLoadedBuilder;
struct UniqueFrameLoadedT;

struct TaggedFrameLoaded;
struct TaggedFrameLoadedBuilder;
struct TaggedFrameLoadedT;

struct UniqueFrameSubscribe;
struct UniqueFrameSubscribeBuilder;
struct UniqueFrameSubscribeT;

struct TaggedFrameSubscribe;
struct TaggedFrameSubscribeBuilder;
struct TaggedFrameSubscribeT;

struct UniqueFrameUnsubscribe;
struct UniqueFrameUnsubscribeBuilder;
struct UniqueFrameUnsubscribeT;

struct TaggedFrameUnsubscribe;
struct TaggedFrameUnsubscribeBuilder;
struct TaggedFrameUnsubscribeT;

struct UniqueFrameNotify;
struct UniqueFrameNotifyBuilder;
struct UniqueFrameNotifyT;

struct TaggedFrameNotify;
struct TaggedFrameNotifyBuilder;
struct TaggedFrameNotifyT;

struct ValueBoolean;
struct ValueBooleanBuilder;
struct ValueBooleanT;

struct ValueNumber;
struct ValueNumberBuilder;
struct ValueNumberT;

struct ValueDouble;
struct ValueDoubleBuilder;
struct ValueDoubleT;

struct ValueString;
struct ValueStringBuilder;
struct ValueStringT;

struct ValueBuffer;
struct ValueBufferBuilder;
struct ValueBufferT;

struct Value;
struct ValueBuilder;
struct ValueT;

struct UniqueValueRequest;
struct UniqueValueRequestBuilder;
struct UniqueValueRequestT;

struct TaggedValueRequest;
struct TaggedValueRequestBuilder;
struct TaggedValueRequestT;

struct UniqueValueResponse;
struct UniqueValueResponseBuilder;
struct UniqueValueResponseT;

struct TaggedValueResponse;
struct TaggedValueResponseBuilder;
struct TaggedValueResponseT;

struct UniqueValueUpdate;
struct UniqueValueUpdateBuilder;
struct UniqueValueUpdateT;

struct TaggedValueUpdate;
struct TaggedValueUpdateBuilder;
struct TaggedValueUpdateT;

struct Signal;
struct SignalBuilder;
struct SignalT;

struct UniqueSignalRequest;
struct UniqueSignalRequestBuilder;
struct UniqueSignalRequestT;

struct TaggedSignalRequest;
struct TaggedSignalRequestBuilder;
struct TaggedSignalRequestT;

struct UniqueSignalResponse;
struct UniqueSignalResponseBuilder;
struct UniqueSignalResponseT;

struct TaggedSignalResponse;
struct TaggedSignalResponseBuilder;
struct TaggedSignalResponseT;

struct UniqueSignalNotify;
struct UniqueSignalNotifyBuilder;
struct UniqueSignalNotifyT;

struct TaggedSignalNotify;
struct TaggedSignalNotifyBuilder;
struct TaggedSignalNotifyT;

enum MessageType : int32_t {
  MessageType_Client_Unique_FrameInfo_Request = 0,
  MessageType_Client_Tagged_FrameInfo_Request = 1,
  MessageType_Server_Unique_FrameInfo_File_Response = 2,
  MessageType_Server_Tagged_FrameInfo_File_Response = 3,
  MessageType_Server_Unique_FrameInfo_Content_Response = 4,
  MessageType_Server_Tagged_FrameInfo_Content_Response = 5,
  MessageType_Client_File_Request = 6,
  MessageType_Server_File_Response = 7,
  MessageType_Client_File_Alias_Request = 8,
  MessageType_Server_File_Alias_Response = 9,
  MessageType_Client_Unique_FrameCache = 10,
  MessageType_Client_Tagged_FrameCache = 11,
  MessageType_Client_Unique_Frame_Loaded = 12,
  MessageType_Client_Tagged_Frame_Loaded = 13,
  MessageType_Client_Unique_Frame_Subscribe = 14,
  MessageType_Client_Tagged_Frame_Subscribe = 15,
  MessageType_Client_Unique_Frame_Unsubscribe = 16,
  MessageType_Client_Tagged_Frame_Unsubscribe = 17,
  MessageType_Client_Unique_Value_Request = 18,
  MessageType_Client_Tagged_Value_Request = 19,
  MessageType_Server_Unique_Value_Response = 20,
  MessageType_Server_Tagged_Value_Response = 21,
  MessageType_Unique_Value_Update = 22,
  MessageType_Tagged_Value_Update = 23,
  MessageType_Client_Unique_Signal_Request = 24,
  MessageType_Client_Tagged_Signal_Request = 25,
  MessageType_Server_Unique_Signal_Response = 26,
  MessageType_Server_Tagged_Signal_Response = 27,
  MessageType_Client_Unique_Signal_Notify = 28,
  MessageType_Client_Tagged_Signal_Notify = 29,
  MessageType_MIN = MessageType_Client_Unique_FrameInfo_Request,
  MessageType_MAX = MessageType_Client_Tagged_Signal_Notify
};

inline const MessageType (&EnumValuesMessageType())[30] {
  static const MessageType values[] = {
    MessageType_Client_Unique_FrameInfo_Request,
    MessageType_Client_Tagged_FrameInfo_Request,
    MessageType_Server_Unique_FrameInfo_File_Response,
    MessageType_Server_Tagged_FrameInfo_File_Response,
    MessageType_Server_Unique_FrameInfo_Content_Response,
    MessageType_Server_Tagged_FrameInfo_Content_Response,
    MessageType_Client_File_Request,
    MessageType_Server_File_Response,
    MessageType_Client_File_Alias_Request,
    MessageType_Server_File_Alias_Response,
    MessageType_Client_Unique_FrameCache,
    MessageType_Client_Tagged_FrameCache,
    MessageType_Client_Unique_Frame_Loaded,
    MessageType_Client_Tagged_Frame_Loaded,
    MessageType_Client_Unique_Frame_Subscribe,
    MessageType_Client_Tagged_Frame_Subscribe,
    MessageType_Client_Unique_Frame_Unsubscribe,
    MessageType_Client_Tagged_Frame_Unsubscribe,
    MessageType_Client_Unique_Value_Request,
    MessageType_Client_Tagged_Value_Request,
    MessageType_Server_Unique_Value_Response,
    MessageType_Server_Tagged_Value_Response,
    MessageType_Unique_Value_Update,
    MessageType_Tagged_Value_Update,
    MessageType_Client_Unique_Signal_Request,
    MessageType_Client_Tagged_Signal_Request,
    MessageType_Server_Unique_Signal_Response,
    MessageType_Server_Tagged_Signal_Response,
    MessageType_Client_Unique_Signal_Notify,
    MessageType_Client_Tagged_Signal_Notify
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[31] = {
    "Client_Unique_FrameInfo_Request",
    "Client_Tagged_FrameInfo_Request",
    "Server_Unique_FrameInfo_File_Response",
    "Server_Tagged_FrameInfo_File_Response",
    "Server_Unique_FrameInfo_Content_Response",
    "Server_Tagged_FrameInfo_Content_Response",
    "Client_File_Request",
    "Server_File_Response",
    "Client_File_Alias_Request",
    "Server_File_Alias_Response",
    "Client_Unique_FrameCache",
    "Client_Tagged_FrameCache",
    "Client_Unique_Frame_Loaded",
    "Client_Tagged_Frame_Loaded",
    "Client_Unique_Frame_Subscribe",
    "Client_Tagged_Frame_Subscribe",
    "Client_Unique_Frame_Unsubscribe",
    "Client_Tagged_Frame_Unsubscribe",
    "Client_Unique_Value_Request",
    "Client_Tagged_Value_Request",
    "Server_Unique_Value_Response",
    "Server_Tagged_Value_Response",
    "Unique_Value_Update",
    "Tagged_Value_Update",
    "Client_Unique_Signal_Request",
    "Client_Tagged_Signal_Request",
    "Server_Unique_Signal_Response",
    "Server_Tagged_Signal_Response",
    "Client_Unique_Signal_Notify",
    "Client_Tagged_Signal_Notify",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (::flatbuffers::IsOutRange(e, MessageType_Client_Unique_FrameInfo_Request, MessageType_Client_Tagged_Signal_Notify)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum SignalType : int32_t {
  SignalType_None = 0,
  SignalType_Boolean = 1,
  SignalType_Number = 2,
  SignalType_Double = 3,
  SignalType_String = 4,
  SignalType_Buffer = 5,
  SignalType_MIN = SignalType_None,
  SignalType_MAX = SignalType_Buffer
};

inline const SignalType (&EnumValuesSignalType())[6] {
  static const SignalType values[] = {
    SignalType_None,
    SignalType_Boolean,
    SignalType_Number,
    SignalType_Double,
    SignalType_String,
    SignalType_Buffer
  };
  return values;
}

inline const char * const *EnumNamesSignalType() {
  static const char * const names[7] = {
    "None",
    "Boolean",
    "Number",
    "Double",
    "String",
    "Buffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameSignalType(SignalType e) {
  if (::flatbuffers::IsOutRange(e, SignalType_None, SignalType_Buffer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSignalType()[index];
}

enum ValueUnion : uint8_t {
  ValueUnion_NONE = 0,
  ValueUnion_ValueBoolean = 1,
  ValueUnion_ValueNumber = 2,
  ValueUnion_ValueDouble = 3,
  ValueUnion_ValueString = 4,
  ValueUnion_ValueBuffer = 5,
  ValueUnion_MIN = ValueUnion_NONE,
  ValueUnion_MAX = ValueUnion_ValueBuffer
};

inline const ValueUnion (&EnumValuesValueUnion())[6] {
  static const ValueUnion values[] = {
    ValueUnion_NONE,
    ValueUnion_ValueBoolean,
    ValueUnion_ValueNumber,
    ValueUnion_ValueDouble,
    ValueUnion_ValueString,
    ValueUnion_ValueBuffer
  };
  return values;
}

inline const char * const *EnumNamesValueUnion() {
  static const char * const names[7] = {
    "NONE",
    "ValueBoolean",
    "ValueNumber",
    "ValueDouble",
    "ValueString",
    "ValueBuffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueUnion(ValueUnion e) {
  if (::flatbuffers::IsOutRange(e, ValueUnion_NONE, ValueUnion_ValueBuffer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueUnion()[index];
}

template<typename T> struct ValueUnionTraits {
  static const ValueUnion enum_value = ValueUnion_NONE;
};

template<> struct ValueUnionTraits<nil::xit::fbs::ValueBoolean> {
  static const ValueUnion enum_value = ValueUnion_ValueBoolean;
};

template<> struct ValueUnionTraits<nil::xit::fbs::ValueNumber> {
  static const ValueUnion enum_value = ValueUnion_ValueNumber;
};

template<> struct ValueUnionTraits<nil::xit::fbs::ValueDouble> {
  static const ValueUnion enum_value = ValueUnion_ValueDouble;
};

template<> struct ValueUnionTraits<nil::xit::fbs::ValueString> {
  static const ValueUnion enum_value = ValueUnion_ValueString;
};

template<> struct ValueUnionTraits<nil::xit::fbs::ValueBuffer> {
  static const ValueUnion enum_value = ValueUnion_ValueBuffer;
};

template<typename T> struct ValueUnionUnionTraits {
  static const ValueUnion enum_value = ValueUnion_NONE;
};

template<> struct ValueUnionUnionTraits<nil::xit::fbs::ValueBooleanT> {
  static const ValueUnion enum_value = ValueUnion_ValueBoolean;
};

template<> struct ValueUnionUnionTraits<nil::xit::fbs::ValueNumberT> {
  static const ValueUnion enum_value = ValueUnion_ValueNumber;
};

template<> struct ValueUnionUnionTraits<nil::xit::fbs::ValueDoubleT> {
  static const ValueUnion enum_value = ValueUnion_ValueDouble;
};

template<> struct ValueUnionUnionTraits<nil::xit::fbs::ValueStringT> {
  static const ValueUnion enum_value = ValueUnion_ValueString;
};

template<> struct ValueUnionUnionTraits<nil::xit::fbs::ValueBufferT> {
  static const ValueUnion enum_value = ValueUnion_ValueBuffer;
};

struct ValueUnionUnion {
  ValueUnion type;
  void *value;

  ValueUnionUnion() : type(ValueUnion_NONE), value(nullptr) {}
  ValueUnionUnion(ValueUnionUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ValueUnion_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ValueUnionUnion(const ValueUnionUnion &);
  ValueUnionUnion &operator=(const ValueUnionUnion &u)
    { ValueUnionUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ValueUnionUnion &operator=(ValueUnionUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ValueUnionUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ValueUnionUnionTraits<RT>::enum_value;
    if (type != ValueUnion_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ValueUnion type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  nil::xit::fbs::ValueBooleanT *AsValueBoolean() {
    return type == ValueUnion_ValueBoolean ?
      reinterpret_cast<nil::xit::fbs::ValueBooleanT *>(value) : nullptr;
  }
  const nil::xit::fbs::ValueBooleanT *AsValueBoolean() const {
    return type == ValueUnion_ValueBoolean ?
      reinterpret_cast<const nil::xit::fbs::ValueBooleanT *>(value) : nullptr;
  }
  nil::xit::fbs::ValueNumberT *AsValueNumber() {
    return type == ValueUnion_ValueNumber ?
      reinterpret_cast<nil::xit::fbs::ValueNumberT *>(value) : nullptr;
  }
  const nil::xit::fbs::ValueNumberT *AsValueNumber() const {
    return type == ValueUnion_ValueNumber ?
      reinterpret_cast<const nil::xit::fbs::ValueNumberT *>(value) : nullptr;
  }
  nil::xit::fbs::ValueDoubleT *AsValueDouble() {
    return type == ValueUnion_ValueDouble ?
      reinterpret_cast<nil::xit::fbs::ValueDoubleT *>(value) : nullptr;
  }
  const nil::xit::fbs::ValueDoubleT *AsValueDouble() const {
    return type == ValueUnion_ValueDouble ?
      reinterpret_cast<const nil::xit::fbs::ValueDoubleT *>(value) : nullptr;
  }
  nil::xit::fbs::ValueStringT *AsValueString() {
    return type == ValueUnion_ValueString ?
      reinterpret_cast<nil::xit::fbs::ValueStringT *>(value) : nullptr;
  }
  const nil::xit::fbs::ValueStringT *AsValueString() const {
    return type == ValueUnion_ValueString ?
      reinterpret_cast<const nil::xit::fbs::ValueStringT *>(value) : nullptr;
  }
  nil::xit::fbs::ValueBufferT *AsValueBuffer() {
    return type == ValueUnion_ValueBuffer ?
      reinterpret_cast<nil::xit::fbs::ValueBufferT *>(value) : nullptr;
  }
  const nil::xit::fbs::ValueBufferT *AsValueBuffer() const {
    return type == ValueUnion_ValueBuffer ?
      reinterpret_cast<const nil::xit::fbs::ValueBufferT *>(value) : nullptr;
  }
};

bool VerifyValueUnion(::flatbuffers::Verifier &verifier, const void *obj, ValueUnion type);
bool VerifyValueUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct UniqueFrameInfoRequestT : public ::flatbuffers::NativeTable {
  typedef UniqueFrameInfoRequest TableType;
  std::string id{};
};

struct UniqueFrameInfoRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueFrameInfoRequestT NativeTableType;
  typedef UniqueFrameInfoRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueFrameInfoRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueFrameInfoRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueFrameInfoRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueFrameInfoRequestBuilder {
  typedef UniqueFrameInfoRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueFrameInfoRequest::VT_ID, id);
  }
  explicit UniqueFrameInfoRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueFrameInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueFrameInfoRequest>(end);
    fbb_.Required(o, UniqueFrameInfoRequest::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueFrameInfoRequest> CreateUniqueFrameInfoRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueFrameInfoRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueFrameInfoRequest> CreateUniqueFrameInfoRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueFrameInfoRequest(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueFrameInfoRequest> CreateUniqueFrameInfoRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedFrameInfoRequestT : public ::flatbuffers::NativeTable {
  typedef TaggedFrameInfoRequest TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedFrameInfoRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedFrameInfoRequestT NativeTableType;
  typedef TaggedFrameInfoRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedFrameInfoRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedFrameInfoRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedFrameInfoRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedFrameInfoRequestBuilder {
  typedef TaggedFrameInfoRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedFrameInfoRequest::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedFrameInfoRequest::VT_TAG, tag);
  }
  explicit TaggedFrameInfoRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedFrameInfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedFrameInfoRequest>(end);
    fbb_.Required(o, TaggedFrameInfoRequest::VT_ID);
    fbb_.Required(o, TaggedFrameInfoRequest::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedFrameInfoRequest> CreateTaggedFrameInfoRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedFrameInfoRequestBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedFrameInfoRequest> CreateTaggedFrameInfoRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedFrameInfoRequest(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedFrameInfoRequest> CreateTaggedFrameInfoRequest(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueFrameInfoResponseT : public ::flatbuffers::NativeTable {
  typedef UniqueFrameInfoResponse TableType;
  std::string id{};
  std::string value{};
};

struct UniqueFrameInfoResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueFrameInfoResponseT NativeTableType;
  typedef UniqueFrameInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  UniqueFrameInfoResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueFrameInfoResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueFrameInfoResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueFrameInfoResponseBuilder {
  typedef UniqueFrameInfoResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueFrameInfoResponse::VT_ID, id);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(UniqueFrameInfoResponse::VT_VALUE, value);
  }
  explicit UniqueFrameInfoResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueFrameInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueFrameInfoResponse>(end);
    fbb_.Required(o, UniqueFrameInfoResponse::VT_ID);
    fbb_.Required(o, UniqueFrameInfoResponse::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueFrameInfoResponse> CreateUniqueFrameInfoResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  UniqueFrameInfoResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueFrameInfoResponse> CreateUniqueFrameInfoResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *value = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return nil::xit::fbs::CreateUniqueFrameInfoResponse(
      _fbb,
      id__,
      value__);
}

::flatbuffers::Offset<UniqueFrameInfoResponse> CreateUniqueFrameInfoResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedFrameInfoResponseT : public ::flatbuffers::NativeTable {
  typedef TaggedFrameInfoResponse TableType;
  std::string id{};
  std::string tag{};
  std::string value{};
};

struct TaggedFrameInfoResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedFrameInfoResponseT NativeTableType;
  typedef TaggedFrameInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  TaggedFrameInfoResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedFrameInfoResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedFrameInfoResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedFrameInfoResponseBuilder {
  typedef TaggedFrameInfoResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedFrameInfoResponse::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedFrameInfoResponse::VT_TAG, tag);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(TaggedFrameInfoResponse::VT_VALUE, value);
  }
  explicit TaggedFrameInfoResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedFrameInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedFrameInfoResponse>(end);
    fbb_.Required(o, TaggedFrameInfoResponse::VT_ID);
    fbb_.Required(o, TaggedFrameInfoResponse::VT_TAG);
    fbb_.Required(o, TaggedFrameInfoResponse::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedFrameInfoResponse> CreateTaggedFrameInfoResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  TaggedFrameInfoResponseBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedFrameInfoResponse> CreateTaggedFrameInfoResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr,
    const char *value = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return nil::xit::fbs::CreateTaggedFrameInfoResponse(
      _fbb,
      id__,
      tag__,
      value__);
}

::flatbuffers::Offset<TaggedFrameInfoResponse> CreateTaggedFrameInfoResponse(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileRequestT : public ::flatbuffers::NativeTable {
  typedef FileRequest TableType;
  std::string target{};
};

struct FileRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileRequestT NativeTableType;
  typedef FileRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4
  };
  const ::flatbuffers::String *target() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyString(target()) &&
           verifier.EndTable();
  }
  FileRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FileRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileRequestBuilder {
  typedef FileRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<::flatbuffers::String> target) {
    fbb_.AddOffset(FileRequest::VT_TARGET, target);
  }
  explicit FileRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileRequest>(end);
    fbb_.Required(o, FileRequest::VT_TARGET);
    return o;
  }
};

inline ::flatbuffers::Offset<FileRequest> CreateFileRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> target = 0) {
  FileRequestBuilder builder_(_fbb);
  builder_.add_target(target);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileRequest> CreateFileRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *target = nullptr) {
  auto target__ = target ? _fbb.CreateString(target) : 0;
  return nil::xit::fbs::CreateFileRequest(
      _fbb,
      target__);
}

::flatbuffers::Offset<FileRequest> CreateFileRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FileRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileAliasRequestT : public ::flatbuffers::NativeTable {
  typedef FileAliasRequest TableType;
};

struct FileAliasRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileAliasRequestT NativeTableType;
  typedef FileAliasRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  FileAliasRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileAliasRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FileAliasRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileAliasRequestBuilder {
  typedef FileAliasRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FileAliasRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileAliasRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileAliasRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FileAliasRequest> CreateFileAliasRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FileAliasRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<FileAliasRequest> CreateFileAliasRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileInfoT : public ::flatbuffers::NativeTable {
  typedef FileInfo TableType;
  std::string target{};
  std::vector<uint8_t> metadata{};
};

struct FileInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileInfoT NativeTableType;
  typedef FileInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_METADATA = 6
  };
  const ::flatbuffers::String *target() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET);
  }
  const ::flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyString(target()) &&
           VerifyOffsetRequired(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.EndTable();
  }
  FileInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FileInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileInfoBuilder {
  typedef FileInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<::flatbuffers::String> target) {
    fbb_.AddOffset(FileInfo::VT_TARGET, target);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(FileInfo::VT_METADATA, metadata);
  }
  explicit FileInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileInfo>(end);
    fbb_.Required(o, FileInfo::VT_TARGET);
    fbb_.Required(o, FileInfo::VT_METADATA);
    return o;
  }
};

inline ::flatbuffers::Offset<FileInfo> CreateFileInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> target = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata = 0) {
  FileInfoBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_target(target);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileInfo> CreateFileInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *target = nullptr,
    const std::vector<uint8_t> *metadata = nullptr) {
  auto target__ = target ? _fbb.CreateString(target) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  return nil::xit::fbs::CreateFileInfo(
      _fbb,
      target__,
      metadata__);
}

::flatbuffers::Offset<FileInfo> CreateFileInfo(::flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileResponseT : public ::flatbuffers::NativeTable {
  typedef FileResponse TableType;
  std::string target{};
  std::string content{};
  std::vector<uint8_t> metadata{};
};

struct FileResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileResponseT NativeTableType;
  typedef FileResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET = 4,
    VT_CONTENT = 6,
    VT_METADATA = 8
  };
  const ::flatbuffers::String *target() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET);
  }
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  const ::flatbuffers::Vector<uint8_t> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyString(target()) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           VerifyOffsetRequired(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.EndTable();
  }
  FileResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FileResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileResponseBuilder {
  typedef FileResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target(::flatbuffers::Offset<::flatbuffers::String> target) {
    fbb_.AddOffset(FileResponse::VT_TARGET, target);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(FileResponse::VT_CONTENT, content);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata) {
    fbb_.AddOffset(FileResponse::VT_METADATA, metadata);
  }
  explicit FileResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileResponse>(end);
    fbb_.Required(o, FileResponse::VT_TARGET);
    fbb_.Required(o, FileResponse::VT_CONTENT);
    fbb_.Required(o, FileResponse::VT_METADATA);
    return o;
  }
};

inline ::flatbuffers::Offset<FileResponse> CreateFileResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> metadata = 0) {
  FileResponseBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_content(content);
  builder_.add_target(target);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileResponse> CreateFileResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *target = nullptr,
    const char *content = nullptr,
    const std::vector<uint8_t> *metadata = nullptr) {
  auto target__ = target ? _fbb.CreateString(target) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<uint8_t>(*metadata) : 0;
  return nil::xit::fbs::CreateFileResponse(
      _fbb,
      target__,
      content__,
      metadata__);
}

::flatbuffers::Offset<FileResponse> CreateFileResponse(::flatbuffers::FlatBufferBuilder &_fbb, const FileResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileAliasT : public ::flatbuffers::NativeTable {
  typedef FileAlias TableType;
  std::string key{};
  std::string value{};
};

struct FileAlias FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileAliasT NativeTableType;
  typedef FileAliasBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  FileAliasT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileAliasT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FileAlias> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileAliasBuilder {
  typedef FileAlias Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(FileAlias::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(FileAlias::VT_VALUE, value);
  }
  explicit FileAliasBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileAlias> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileAlias>(end);
    fbb_.Required(o, FileAlias::VT_KEY);
    fbb_.Required(o, FileAlias::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<FileAlias> CreateFileAlias(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  FileAliasBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileAlias> CreateFileAliasDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return nil::xit::fbs::CreateFileAlias(
      _fbb,
      key__,
      value__);
}

::flatbuffers::Offset<FileAlias> CreateFileAlias(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileAliasResponseT : public ::flatbuffers::NativeTable {
  typedef FileAliasResponse TableType;
  std::vector<std::unique_ptr<nil::xit::fbs::FileAliasT>> aliases{};
  FileAliasResponseT() = default;
  FileAliasResponseT(const FileAliasResponseT &o);
  FileAliasResponseT(FileAliasResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  FileAliasResponseT &operator=(FileAliasResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct FileAliasResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileAliasResponseT NativeTableType;
  typedef FileAliasResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALIASES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>> *aliases() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>> *>(VT_ALIASES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ALIASES) &&
           verifier.VerifyVector(aliases()) &&
           verifier.VerifyVectorOfTables(aliases()) &&
           verifier.EndTable();
  }
  FileAliasResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileAliasResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FileAliasResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileAliasResponseBuilder {
  typedef FileAliasResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_aliases(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>>> aliases) {
    fbb_.AddOffset(FileAliasResponse::VT_ALIASES, aliases);
  }
  explicit FileAliasResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileAliasResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileAliasResponse>(end);
    fbb_.Required(o, FileAliasResponse::VT_ALIASES);
    return o;
  }
};

inline ::flatbuffers::Offset<FileAliasResponse> CreateFileAliasResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>>> aliases = 0) {
  FileAliasResponseBuilder builder_(_fbb);
  builder_.add_aliases(aliases);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileAliasResponse> CreateFileAliasResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>> *aliases = nullptr) {
  auto aliases__ = aliases ? _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>>(*aliases) : 0;
  return nil::xit::fbs::CreateFileAliasResponse(
      _fbb,
      aliases__);
}

::flatbuffers::Offset<FileAliasResponse> CreateFileAliasResponse(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameCacheT : public ::flatbuffers::NativeTable {
  typedef FrameCache TableType;
  std::string id{};
  std::string target{};
  std::string full_target{};
  std::string content{};
  std::vector<std::unique_ptr<nil::xit::fbs::FileInfoT>> files{};
  FrameCacheT() = default;
  FrameCacheT(const FrameCacheT &o);
  FrameCacheT(FrameCacheT&&) FLATBUFFERS_NOEXCEPT = default;
  FrameCacheT &operator=(FrameCacheT o) FLATBUFFERS_NOEXCEPT;
};

struct FrameCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameCacheT NativeTableType;
  typedef FrameCacheBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TARGET = 6,
    VT_FULL_TARGET = 8,
    VT_CONTENT = 10,
    VT_FILES = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *target() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET);
  }
  const ::flatbuffers::String *full_target() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FULL_TARGET);
  }
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>> *files() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>> *>(VT_FILES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TARGET) &&
           verifier.VerifyString(target()) &&
           VerifyOffsetRequired(verifier, VT_FULL_TARGET) &&
           verifier.VerifyString(full_target()) &&
           VerifyOffsetRequired(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           VerifyOffsetRequired(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           verifier.EndTable();
  }
  FrameCacheT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameCacheT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FrameCache> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameCacheT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameCacheBuilder {
  typedef FrameCache Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(FrameCache::VT_ID, id);
  }
  void add_target(::flatbuffers::Offset<::flatbuffers::String> target) {
    fbb_.AddOffset(FrameCache::VT_TARGET, target);
  }
  void add_full_target(::flatbuffers::Offset<::flatbuffers::String> full_target) {
    fbb_.AddOffset(FrameCache::VT_FULL_TARGET, full_target);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(FrameCache::VT_CONTENT, content);
  }
  void add_files(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>>> files) {
    fbb_.AddOffset(FrameCache::VT_FILES, files);
  }
  explicit FrameCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FrameCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FrameCache>(end);
    fbb_.Required(o, FrameCache::VT_ID);
    fbb_.Required(o, FrameCache::VT_TARGET);
    fbb_.Required(o, FrameCache::VT_FULL_TARGET);
    fbb_.Required(o, FrameCache::VT_CONTENT);
    fbb_.Required(o, FrameCache::VT_FILES);
    return o;
  }
};

inline ::flatbuffers::Offset<FrameCache> CreateFrameCache(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> full_target = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>>> files = 0) {
  FrameCacheBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_content(content);
  builder_.add_full_target(full_target);
  builder_.add_target(target);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FrameCache> CreateFrameCacheDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *target = nullptr,
    const char *full_target = nullptr,
    const char *content = nullptr,
    const std::vector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>> *files = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto target__ = target ? _fbb.CreateString(target) : 0;
  auto full_target__ = full_target ? _fbb.CreateString(full_target) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  auto files__ = files ? _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>>(*files) : 0;
  return nil::xit::fbs::CreateFrameCache(
      _fbb,
      id__,
      target__,
      full_target__,
      content__,
      files__);
}

::flatbuffers::Offset<FrameCache> CreateFrameCache(::flatbuffers::FlatBufferBuilder &_fbb, const FrameCacheT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueFrameLoadedT : public ::flatbuffers::NativeTable {
  typedef UniqueFrameLoaded TableType;
  std::string id{};
};

struct UniqueFrameLoaded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueFrameLoadedT NativeTableType;
  typedef UniqueFrameLoadedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueFrameLoadedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueFrameLoadedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueFrameLoaded> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameLoadedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueFrameLoadedBuilder {
  typedef UniqueFrameLoaded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueFrameLoaded::VT_ID, id);
  }
  explicit UniqueFrameLoadedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueFrameLoaded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueFrameLoaded>(end);
    fbb_.Required(o, UniqueFrameLoaded::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueFrameLoaded> CreateUniqueFrameLoaded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueFrameLoadedBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueFrameLoaded> CreateUniqueFrameLoadedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueFrameLoaded(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueFrameLoaded> CreateUniqueFrameLoaded(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameLoadedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedFrameLoadedT : public ::flatbuffers::NativeTable {
  typedef TaggedFrameLoaded TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedFrameLoaded FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedFrameLoadedT NativeTableType;
  typedef TaggedFrameLoadedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedFrameLoadedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedFrameLoadedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedFrameLoaded> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameLoadedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedFrameLoadedBuilder {
  typedef TaggedFrameLoaded Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedFrameLoaded::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedFrameLoaded::VT_TAG, tag);
  }
  explicit TaggedFrameLoadedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedFrameLoaded> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedFrameLoaded>(end);
    fbb_.Required(o, TaggedFrameLoaded::VT_ID);
    fbb_.Required(o, TaggedFrameLoaded::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedFrameLoaded> CreateTaggedFrameLoaded(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedFrameLoadedBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedFrameLoaded> CreateTaggedFrameLoadedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedFrameLoaded(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedFrameLoaded> CreateTaggedFrameLoaded(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameLoadedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueFrameSubscribeT : public ::flatbuffers::NativeTable {
  typedef UniqueFrameSubscribe TableType;
  std::string id{};
};

struct UniqueFrameSubscribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueFrameSubscribeT NativeTableType;
  typedef UniqueFrameSubscribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueFrameSubscribeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueFrameSubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueFrameSubscribe> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameSubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueFrameSubscribeBuilder {
  typedef UniqueFrameSubscribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueFrameSubscribe::VT_ID, id);
  }
  explicit UniqueFrameSubscribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueFrameSubscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueFrameSubscribe>(end);
    fbb_.Required(o, UniqueFrameSubscribe::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueFrameSubscribe> CreateUniqueFrameSubscribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueFrameSubscribeBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueFrameSubscribe> CreateUniqueFrameSubscribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueFrameSubscribe(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueFrameSubscribe> CreateUniqueFrameSubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameSubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedFrameSubscribeT : public ::flatbuffers::NativeTable {
  typedef TaggedFrameSubscribe TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedFrameSubscribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedFrameSubscribeT NativeTableType;
  typedef TaggedFrameSubscribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedFrameSubscribeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedFrameSubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedFrameSubscribe> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameSubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedFrameSubscribeBuilder {
  typedef TaggedFrameSubscribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedFrameSubscribe::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedFrameSubscribe::VT_TAG, tag);
  }
  explicit TaggedFrameSubscribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedFrameSubscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedFrameSubscribe>(end);
    fbb_.Required(o, TaggedFrameSubscribe::VT_ID);
    fbb_.Required(o, TaggedFrameSubscribe::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedFrameSubscribe> CreateTaggedFrameSubscribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedFrameSubscribeBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedFrameSubscribe> CreateTaggedFrameSubscribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedFrameSubscribe(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedFrameSubscribe> CreateTaggedFrameSubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameSubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueFrameUnsubscribeT : public ::flatbuffers::NativeTable {
  typedef UniqueFrameUnsubscribe TableType;
  std::string id{};
};

struct UniqueFrameUnsubscribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueFrameUnsubscribeT NativeTableType;
  typedef UniqueFrameUnsubscribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueFrameUnsubscribeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueFrameUnsubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueFrameUnsubscribe> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameUnsubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueFrameUnsubscribeBuilder {
  typedef UniqueFrameUnsubscribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueFrameUnsubscribe::VT_ID, id);
  }
  explicit UniqueFrameUnsubscribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueFrameUnsubscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueFrameUnsubscribe>(end);
    fbb_.Required(o, UniqueFrameUnsubscribe::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueFrameUnsubscribe> CreateUniqueFrameUnsubscribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueFrameUnsubscribeBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueFrameUnsubscribe> CreateUniqueFrameUnsubscribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueFrameUnsubscribe(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueFrameUnsubscribe> CreateUniqueFrameUnsubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameUnsubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedFrameUnsubscribeT : public ::flatbuffers::NativeTable {
  typedef TaggedFrameUnsubscribe TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedFrameUnsubscribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedFrameUnsubscribeT NativeTableType;
  typedef TaggedFrameUnsubscribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedFrameUnsubscribeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedFrameUnsubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedFrameUnsubscribe> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameUnsubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedFrameUnsubscribeBuilder {
  typedef TaggedFrameUnsubscribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedFrameUnsubscribe::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedFrameUnsubscribe::VT_TAG, tag);
  }
  explicit TaggedFrameUnsubscribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedFrameUnsubscribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedFrameUnsubscribe>(end);
    fbb_.Required(o, TaggedFrameUnsubscribe::VT_ID);
    fbb_.Required(o, TaggedFrameUnsubscribe::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedFrameUnsubscribe> CreateTaggedFrameUnsubscribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedFrameUnsubscribeBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedFrameUnsubscribe> CreateTaggedFrameUnsubscribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedFrameUnsubscribe(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedFrameUnsubscribe> CreateTaggedFrameUnsubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameUnsubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueFrameNotifyT : public ::flatbuffers::NativeTable {
  typedef UniqueFrameNotify TableType;
  std::string id{};
};

struct UniqueFrameNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueFrameNotifyT NativeTableType;
  typedef UniqueFrameNotifyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueFrameNotifyT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueFrameNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueFrameNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueFrameNotifyBuilder {
  typedef UniqueFrameNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueFrameNotify::VT_ID, id);
  }
  explicit UniqueFrameNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueFrameNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueFrameNotify>(end);
    fbb_.Required(o, UniqueFrameNotify::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueFrameNotify> CreateUniqueFrameNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueFrameNotifyBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueFrameNotify> CreateUniqueFrameNotifyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueFrameNotify(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueFrameNotify> CreateUniqueFrameNotify(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedFrameNotifyT : public ::flatbuffers::NativeTable {
  typedef TaggedFrameNotify TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedFrameNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedFrameNotifyT NativeTableType;
  typedef TaggedFrameNotifyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedFrameNotifyT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedFrameNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedFrameNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedFrameNotifyBuilder {
  typedef TaggedFrameNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedFrameNotify::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedFrameNotify::VT_TAG, tag);
  }
  explicit TaggedFrameNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedFrameNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedFrameNotify>(end);
    fbb_.Required(o, TaggedFrameNotify::VT_ID);
    fbb_.Required(o, TaggedFrameNotify::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedFrameNotify> CreateTaggedFrameNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedFrameNotifyBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedFrameNotify> CreateTaggedFrameNotifyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedFrameNotify(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedFrameNotify> CreateTaggedFrameNotify(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValueBooleanT : public ::flatbuffers::NativeTable {
  typedef ValueBoolean TableType;
  bool value = false;
};

struct ValueBoolean FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBooleanT NativeTableType;
  typedef ValueBooleanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
  ValueBooleanT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValueBooleanT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ValueBoolean> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBooleanT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValueBooleanBuilder {
  typedef ValueBoolean Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(ValueBoolean::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit ValueBooleanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueBoolean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueBoolean>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueBoolean> CreateValueBoolean(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  ValueBooleanBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

::flatbuffers::Offset<ValueBoolean> CreateValueBoolean(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBooleanT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValueNumberT : public ::flatbuffers::NativeTable {
  typedef ValueNumber TableType;
  int64_t value = 0;
};

struct ValueNumber FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueNumberT NativeTableType;
  typedef ValueNumberBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  ValueNumberT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValueNumberT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ValueNumber> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueNumberT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValueNumberBuilder {
  typedef ValueNumber Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(ValueNumber::VT_VALUE, value, 0);
  }
  explicit ValueNumberBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueNumber> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueNumber>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueNumber> CreateValueNumber(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  ValueNumberBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

::flatbuffers::Offset<ValueNumber> CreateValueNumber(::flatbuffers::FlatBufferBuilder &_fbb, const ValueNumberT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValueDoubleT : public ::flatbuffers::NativeTable {
  typedef ValueDouble TableType;
  double value = 0.0;
};

struct ValueDouble FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueDoubleT NativeTableType;
  typedef ValueDoubleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE, 8) &&
           verifier.EndTable();
  }
  ValueDoubleT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValueDoubleT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ValueDouble> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueDoubleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValueDoubleBuilder {
  typedef ValueDouble Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(ValueDouble::VT_VALUE, value, 0.0);
  }
  explicit ValueDoubleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueDouble> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueDouble>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueDouble> CreateValueDouble(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  ValueDoubleBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

::flatbuffers::Offset<ValueDouble> CreateValueDouble(::flatbuffers::FlatBufferBuilder &_fbb, const ValueDoubleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValueStringT : public ::flatbuffers::NativeTable {
  typedef ValueString TableType;
  std::string value{};
};

struct ValueString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueStringT NativeTableType;
  typedef ValueStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  ValueStringT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValueStringT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ValueString> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueStringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValueStringBuilder {
  typedef ValueString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(ValueString::VT_VALUE, value);
  }
  explicit ValueStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueString> CreateValueString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  ValueStringBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ValueString> CreateValueStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return nil::xit::fbs::CreateValueString(
      _fbb,
      value__);
}

::flatbuffers::Offset<ValueString> CreateValueString(::flatbuffers::FlatBufferBuilder &_fbb, const ValueStringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValueBufferT : public ::flatbuffers::NativeTable {
  typedef ValueBuffer TableType;
  std::vector<uint8_t> value{};
};

struct ValueBuffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueBufferT NativeTableType;
  typedef ValueBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *value() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
  ValueBufferT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValueBufferT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ValueBuffer> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ValueBufferBuilder {
  typedef ValueBuffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value) {
    fbb_.AddOffset(ValueBuffer::VT_VALUE, value);
  }
  explicit ValueBufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ValueBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ValueBuffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ValueBuffer> CreateValueBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> value = 0) {
  ValueBufferBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ValueBuffer> CreateValueBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<uint8_t>(*value) : 0;
  return nil::xit::fbs::CreateValueBuffer(
      _fbb,
      value__);
}

::flatbuffers::Offset<ValueBuffer> CreateValueBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ValueT : public ::flatbuffers::NativeTable {
  typedef Value TableType;
  std::string id{};
  nil::xit::fbs::ValueUnionUnion value{};
};

struct Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ValueT NativeTableType;
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  nil::xit::fbs::ValueUnion value_type() const {
    return static_cast<nil::xit::fbs::ValueUnion>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const nil::xit::fbs::ValueBoolean *value_as_ValueBoolean() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueBoolean ? static_cast<const nil::xit::fbs::ValueBoolean *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueNumber *value_as_ValueNumber() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueNumber ? static_cast<const nil::xit::fbs::ValueNumber *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueDouble *value_as_ValueDouble() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueDouble ? static_cast<const nil::xit::fbs::ValueDouble *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueString *value_as_ValueString() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueString ? static_cast<const nil::xit::fbs::ValueString *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueBuffer *value_as_ValueBuffer() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueBuffer ? static_cast<const nil::xit::fbs::ValueBuffer *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyValueUnion(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  ValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Value> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const nil::xit::fbs::ValueBoolean *Value::value_as<nil::xit::fbs::ValueBoolean>() const {
  return value_as_ValueBoolean();
}

template<> inline const nil::xit::fbs::ValueNumber *Value::value_as<nil::xit::fbs::ValueNumber>() const {
  return value_as_ValueNumber();
}

template<> inline const nil::xit::fbs::ValueDouble *Value::value_as<nil::xit::fbs::ValueDouble>() const {
  return value_as_ValueDouble();
}

template<> inline const nil::xit::fbs::ValueString *Value::value_as<nil::xit::fbs::ValueString>() const {
  return value_as_ValueString();
}

template<> inline const nil::xit::fbs::ValueBuffer *Value::value_as<nil::xit::fbs::ValueBuffer>() const {
  return value_as_ValueBuffer();
}

struct ValueBuilder {
  typedef Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Value::VT_ID, id);
  }
  void add_value_type(nil::xit::fbs::ValueUnion value_type) {
    fbb_.AddElement<uint8_t>(Value::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Value::VT_VALUE, value);
  }
  explicit ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Value>(end);
    fbb_.Required(o, Value::VT_ID);
    fbb_.Required(o, Value::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<Value> CreateValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    nil::xit::fbs::ValueUnion value_type = nil::xit::fbs::ValueUnion_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_id(id);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Value> CreateValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    nil::xit::fbs::ValueUnion value_type = nil::xit::fbs::ValueUnion_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateValue(
      _fbb,
      id__,
      value_type,
      value);
}

::flatbuffers::Offset<Value> CreateValue(::flatbuffers::FlatBufferBuilder &_fbb, const ValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueValueRequestT : public ::flatbuffers::NativeTable {
  typedef UniqueValueRequest TableType;
  std::string id{};
};

struct UniqueValueRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueValueRequestT NativeTableType;
  typedef UniqueValueRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueValueRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueValueRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueValueRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueValueRequestBuilder {
  typedef UniqueValueRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueValueRequest::VT_ID, id);
  }
  explicit UniqueValueRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueValueRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueValueRequest>(end);
    fbb_.Required(o, UniqueValueRequest::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueValueRequest> CreateUniqueValueRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueValueRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueValueRequest> CreateUniqueValueRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueValueRequest(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueValueRequest> CreateUniqueValueRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedValueRequestT : public ::flatbuffers::NativeTable {
  typedef TaggedValueRequest TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedValueRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedValueRequestT NativeTableType;
  typedef TaggedValueRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedValueRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedValueRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedValueRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedValueRequestBuilder {
  typedef TaggedValueRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedValueRequest::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedValueRequest::VT_TAG, tag);
  }
  explicit TaggedValueRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedValueRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedValueRequest>(end);
    fbb_.Required(o, TaggedValueRequest::VT_ID);
    fbb_.Required(o, TaggedValueRequest::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedValueRequest> CreateTaggedValueRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedValueRequestBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedValueRequest> CreateTaggedValueRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedValueRequest(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedValueRequest> CreateTaggedValueRequest(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueValueResponseT : public ::flatbuffers::NativeTable {
  typedef UniqueValueResponse TableType;
  std::string id{};
  std::vector<std::unique_ptr<nil::xit::fbs::ValueT>> values{};
  UniqueValueResponseT() = default;
  UniqueValueResponseT(const UniqueValueResponseT &o);
  UniqueValueResponseT(UniqueValueResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  UniqueValueResponseT &operator=(UniqueValueResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct UniqueValueResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueValueResponseT NativeTableType;
  typedef UniqueValueResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
  UniqueValueResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueValueResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueValueResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueValueResponseBuilder {
  typedef UniqueValueResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueValueResponse::VT_ID, id);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>>> values) {
    fbb_.AddOffset(UniqueValueResponse::VT_VALUES, values);
  }
  explicit UniqueValueResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueValueResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueValueResponse>(end);
    fbb_.Required(o, UniqueValueResponse::VT_ID);
    fbb_.Required(o, UniqueValueResponse::VT_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueValueResponse> CreateUniqueValueResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>>> values = 0) {
  UniqueValueResponseBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueValueResponse> CreateUniqueValueResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<::flatbuffers::Offset<nil::xit::fbs::Value>> *values = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Value>>(*values) : 0;
  return nil::xit::fbs::CreateUniqueValueResponse(
      _fbb,
      id__,
      values__);
}

::flatbuffers::Offset<UniqueValueResponse> CreateUniqueValueResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedValueResponseT : public ::flatbuffers::NativeTable {
  typedef TaggedValueResponse TableType;
  std::string id{};
  std::string tag{};
  std::vector<std::unique_ptr<nil::xit::fbs::ValueT>> values{};
  TaggedValueResponseT() = default;
  TaggedValueResponseT(const TaggedValueResponseT &o);
  TaggedValueResponseT(TaggedValueResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  TaggedValueResponseT &operator=(TaggedValueResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct TaggedValueResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedValueResponseT NativeTableType;
  typedef TaggedValueResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6,
    VT_VALUES = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
  TaggedValueResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedValueResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedValueResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedValueResponseBuilder {
  typedef TaggedValueResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedValueResponse::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedValueResponse::VT_TAG, tag);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>>> values) {
    fbb_.AddOffset(TaggedValueResponse::VT_VALUES, values);
  }
  explicit TaggedValueResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedValueResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedValueResponse>(end);
    fbb_.Required(o, TaggedValueResponse::VT_ID);
    fbb_.Required(o, TaggedValueResponse::VT_TAG);
    fbb_.Required(o, TaggedValueResponse::VT_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedValueResponse> CreateTaggedValueResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Value>>> values = 0) {
  TaggedValueResponseBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedValueResponse> CreateTaggedValueResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr,
    const std::vector<::flatbuffers::Offset<nil::xit::fbs::Value>> *values = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Value>>(*values) : 0;
  return nil::xit::fbs::CreateTaggedValueResponse(
      _fbb,
      id__,
      tag__,
      values__);
}

::flatbuffers::Offset<TaggedValueResponse> CreateTaggedValueResponse(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueValueUpdateT : public ::flatbuffers::NativeTable {
  typedef UniqueValueUpdate TableType;
  std::string id{};
  std::unique_ptr<nil::xit::fbs::ValueT> value{};
  UniqueValueUpdateT() = default;
  UniqueValueUpdateT(const UniqueValueUpdateT &o);
  UniqueValueUpdateT(UniqueValueUpdateT&&) FLATBUFFERS_NOEXCEPT = default;
  UniqueValueUpdateT &operator=(UniqueValueUpdateT o) FLATBUFFERS_NOEXCEPT;
};

struct UniqueValueUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueValueUpdateT NativeTableType;
  typedef UniqueValueUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const nil::xit::fbs::Value *value() const {
    return GetPointer<const nil::xit::fbs::Value *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
  UniqueValueUpdateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueValueUpdateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueValueUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueUpdateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueValueUpdateBuilder {
  typedef UniqueValueUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueValueUpdate::VT_ID, id);
  }
  void add_value(::flatbuffers::Offset<nil::xit::fbs::Value> value) {
    fbb_.AddOffset(UniqueValueUpdate::VT_VALUE, value);
  }
  explicit UniqueValueUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueValueUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueValueUpdate>(end);
    fbb_.Required(o, UniqueValueUpdate::VT_ID);
    fbb_.Required(o, UniqueValueUpdate::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueValueUpdate> CreateUniqueValueUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<nil::xit::fbs::Value> value = 0) {
  UniqueValueUpdateBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueValueUpdate> CreateUniqueValueUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    ::flatbuffers::Offset<nil::xit::fbs::Value> value = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueValueUpdate(
      _fbb,
      id__,
      value);
}

::flatbuffers::Offset<UniqueValueUpdate> CreateUniqueValueUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueUpdateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedValueUpdateT : public ::flatbuffers::NativeTable {
  typedef TaggedValueUpdate TableType;
  std::string id{};
  std::string tag{};
  std::unique_ptr<nil::xit::fbs::ValueT> value{};
  TaggedValueUpdateT() = default;
  TaggedValueUpdateT(const TaggedValueUpdateT &o);
  TaggedValueUpdateT(TaggedValueUpdateT&&) FLATBUFFERS_NOEXCEPT = default;
  TaggedValueUpdateT &operator=(TaggedValueUpdateT o) FLATBUFFERS_NOEXCEPT;
};

struct TaggedValueUpdate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedValueUpdateT NativeTableType;
  typedef TaggedValueUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  const nil::xit::fbs::Value *value() const {
    return GetPointer<const nil::xit::fbs::Value *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
  TaggedValueUpdateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedValueUpdateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedValueUpdate> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueUpdateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedValueUpdateBuilder {
  typedef TaggedValueUpdate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedValueUpdate::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedValueUpdate::VT_TAG, tag);
  }
  void add_value(::flatbuffers::Offset<nil::xit::fbs::Value> value) {
    fbb_.AddOffset(TaggedValueUpdate::VT_VALUE, value);
  }
  explicit TaggedValueUpdateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedValueUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedValueUpdate>(end);
    fbb_.Required(o, TaggedValueUpdate::VT_ID);
    fbb_.Required(o, TaggedValueUpdate::VT_TAG);
    fbb_.Required(o, TaggedValueUpdate::VT_VALUE);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedValueUpdate> CreateTaggedValueUpdate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    ::flatbuffers::Offset<nil::xit::fbs::Value> value = 0) {
  TaggedValueUpdateBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedValueUpdate> CreateTaggedValueUpdateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr,
    ::flatbuffers::Offset<nil::xit::fbs::Value> value = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedValueUpdate(
      _fbb,
      id__,
      tag__,
      value);
}

::flatbuffers::Offset<TaggedValueUpdate> CreateTaggedValueUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueUpdateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalT : public ::flatbuffers::NativeTable {
  typedef Signal TableType;
  std::string id{};
  nil::xit::fbs::SignalType type = nil::xit::fbs::SignalType_None;
};

struct Signal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SignalT NativeTableType;
  typedef SignalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  nil::xit::fbs::SignalType type() const {
    return static_cast<nil::xit::fbs::SignalType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
  SignalT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Signal> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalBuilder {
  typedef Signal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Signal::VT_ID, id);
  }
  void add_type(nil::xit::fbs::SignalType type) {
    fbb_.AddElement<int32_t>(Signal::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit SignalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Signal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Signal>(end);
    fbb_.Required(o, Signal::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<Signal> CreateSignal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    nil::xit::fbs::SignalType type = nil::xit::fbs::SignalType_None) {
  SignalBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Signal> CreateSignalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    nil::xit::fbs::SignalType type = nil::xit::fbs::SignalType_None) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateSignal(
      _fbb,
      id__,
      type);
}

::flatbuffers::Offset<Signal> CreateSignal(::flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueSignalRequestT : public ::flatbuffers::NativeTable {
  typedef UniqueSignalRequest TableType;
  std::string id{};
};

struct UniqueSignalRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueSignalRequestT NativeTableType;
  typedef UniqueSignalRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           verifier.EndTable();
  }
  UniqueSignalRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueSignalRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueSignalRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueSignalRequestBuilder {
  typedef UniqueSignalRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueSignalRequest::VT_ID, id);
  }
  explicit UniqueSignalRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueSignalRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueSignalRequest>(end);
    fbb_.Required(o, UniqueSignalRequest::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueSignalRequest> CreateUniqueSignalRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0) {
  UniqueSignalRequestBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueSignalRequest> CreateUniqueSignalRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return nil::xit::fbs::CreateUniqueSignalRequest(
      _fbb,
      id__);
}

::flatbuffers::Offset<UniqueSignalRequest> CreateUniqueSignalRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedSignalRequestT : public ::flatbuffers::NativeTable {
  typedef TaggedSignalRequest TableType;
  std::string id{};
  std::string tag{};
};

struct TaggedSignalRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedSignalRequestT NativeTableType;
  typedef TaggedSignalRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           verifier.EndTable();
  }
  TaggedSignalRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedSignalRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedSignalRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedSignalRequestBuilder {
  typedef TaggedSignalRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedSignalRequest::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedSignalRequest::VT_TAG, tag);
  }
  explicit TaggedSignalRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedSignalRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedSignalRequest>(end);
    fbb_.Required(o, TaggedSignalRequest::VT_ID);
    fbb_.Required(o, TaggedSignalRequest::VT_TAG);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedSignalRequest> CreateTaggedSignalRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0) {
  TaggedSignalRequestBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedSignalRequest> CreateTaggedSignalRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  return nil::xit::fbs::CreateTaggedSignalRequest(
      _fbb,
      id__,
      tag__);
}

::flatbuffers::Offset<TaggedSignalRequest> CreateTaggedSignalRequest(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueSignalResponseT : public ::flatbuffers::NativeTable {
  typedef UniqueSignalResponse TableType;
  std::string id{};
  std::vector<std::unique_ptr<nil::xit::fbs::SignalT>> signals{};
  UniqueSignalResponseT() = default;
  UniqueSignalResponseT(const UniqueSignalResponseT &o);
  UniqueSignalResponseT(UniqueSignalResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  UniqueSignalResponseT &operator=(UniqueSignalResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct UniqueSignalResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueSignalResponseT NativeTableType;
  typedef UniqueSignalResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SIGNALS = 6
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>> *signals() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>> *>(VT_SIGNALS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_SIGNALS) &&
           verifier.VerifyVector(signals()) &&
           verifier.VerifyVectorOfTables(signals()) &&
           verifier.EndTable();
  }
  UniqueSignalResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueSignalResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueSignalResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UniqueSignalResponseBuilder {
  typedef UniqueSignalResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(UniqueSignalResponse::VT_ID, id);
  }
  void add_signals(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>>> signals) {
    fbb_.AddOffset(UniqueSignalResponse::VT_SIGNALS, signals);
  }
  explicit UniqueSignalResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueSignalResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueSignalResponse>(end);
    fbb_.Required(o, UniqueSignalResponse::VT_ID);
    fbb_.Required(o, UniqueSignalResponse::VT_SIGNALS);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueSignalResponse> CreateUniqueSignalResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>>> signals = 0) {
  UniqueSignalResponseBuilder builder_(_fbb);
  builder_.add_signals(signals);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueSignalResponse> CreateUniqueSignalResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<::flatbuffers::Offset<nil::xit::fbs::Signal>> *signals = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto signals__ = signals ? _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Signal>>(*signals) : 0;
  return nil::xit::fbs::CreateUniqueSignalResponse(
      _fbb,
      id__,
      signals__);
}

::flatbuffers::Offset<UniqueSignalResponse> CreateUniqueSignalResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedSignalResponseT : public ::flatbuffers::NativeTable {
  typedef TaggedSignalResponse TableType;
  std::string id{};
  std::string tag{};
  std::vector<std::unique_ptr<nil::xit::fbs::SignalT>> signals{};
  TaggedSignalResponseT() = default;
  TaggedSignalResponseT(const TaggedSignalResponseT &o);
  TaggedSignalResponseT(TaggedSignalResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  TaggedSignalResponseT &operator=(TaggedSignalResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct TaggedSignalResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedSignalResponseT NativeTableType;
  typedef TaggedSignalResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TAG = 6,
    VT_SIGNALS = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>> *signals() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>> *>(VT_SIGNALS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyOffsetRequired(verifier, VT_SIGNALS) &&
           verifier.VerifyVector(signals()) &&
           verifier.VerifyVectorOfTables(signals()) &&
           verifier.EndTable();
  }
  TaggedSignalResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedSignalResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedSignalResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TaggedSignalResponseBuilder {
  typedef TaggedSignalResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TaggedSignalResponse::VT_ID, id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedSignalResponse::VT_TAG, tag);
  }
  void add_signals(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>>> signals) {
    fbb_.AddOffset(TaggedSignalResponse::VT_SIGNALS, signals);
  }
  explicit TaggedSignalResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedSignalResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedSignalResponse>(end);
    fbb_.Required(o, TaggedSignalResponse::VT_ID);
    fbb_.Required(o, TaggedSignalResponse::VT_TAG);
    fbb_.Required(o, TaggedSignalResponse::VT_SIGNALS);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedSignalResponse> CreateTaggedSignalResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<nil::xit::fbs::Signal>>> signals = 0) {
  TaggedSignalResponseBuilder builder_(_fbb);
  builder_.add_signals(signals);
  builder_.add_tag(tag);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedSignalResponse> CreateTaggedSignalResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *tag = nullptr,
    const std::vector<::flatbuffers::Offset<nil::xit::fbs::Signal>> *signals = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  auto signals__ = signals ? _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Signal>>(*signals) : 0;
  return nil::xit::fbs::CreateTaggedSignalResponse(
      _fbb,
      id__,
      tag__,
      signals__);
}

::flatbuffers::Offset<TaggedSignalResponse> CreateTaggedSignalResponse(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UniqueSignalNotifyT : public ::flatbuffers::NativeTable {
  typedef UniqueSignalNotify TableType;
  std::string frame_id{};
  std::string signal_id{};
  nil::xit::fbs::ValueUnionUnion value{};
};

struct UniqueSignalNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UniqueSignalNotifyT NativeTableType;
  typedef UniqueSignalNotifyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_ID = 4,
    VT_SIGNAL_ID = 6,
    VT_VALUE_TYPE = 8,
    VT_VALUE = 10
  };
  const ::flatbuffers::String *frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_ID);
  }
  const ::flatbuffers::String *signal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNAL_ID);
  }
  nil::xit::fbs::ValueUnion value_type() const {
    return static_cast<nil::xit::fbs::ValueUnion>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const nil::xit::fbs::ValueBoolean *value_as_ValueBoolean() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueBoolean ? static_cast<const nil::xit::fbs::ValueBoolean *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueNumber *value_as_ValueNumber() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueNumber ? static_cast<const nil::xit::fbs::ValueNumber *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueDouble *value_as_ValueDouble() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueDouble ? static_cast<const nil::xit::fbs::ValueDouble *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueString *value_as_ValueString() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueString ? static_cast<const nil::xit::fbs::ValueString *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueBuffer *value_as_ValueBuffer() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueBuffer ? static_cast<const nil::xit::fbs::ValueBuffer *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           VerifyOffsetRequired(verifier, VT_SIGNAL_ID) &&
           verifier.VerifyString(signal_id()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueUnion(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  UniqueSignalNotifyT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UniqueSignalNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<UniqueSignalNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const nil::xit::fbs::ValueBoolean *UniqueSignalNotify::value_as<nil::xit::fbs::ValueBoolean>() const {
  return value_as_ValueBoolean();
}

template<> inline const nil::xit::fbs::ValueNumber *UniqueSignalNotify::value_as<nil::xit::fbs::ValueNumber>() const {
  return value_as_ValueNumber();
}

template<> inline const nil::xit::fbs::ValueDouble *UniqueSignalNotify::value_as<nil::xit::fbs::ValueDouble>() const {
  return value_as_ValueDouble();
}

template<> inline const nil::xit::fbs::ValueString *UniqueSignalNotify::value_as<nil::xit::fbs::ValueString>() const {
  return value_as_ValueString();
}

template<> inline const nil::xit::fbs::ValueBuffer *UniqueSignalNotify::value_as<nil::xit::fbs::ValueBuffer>() const {
  return value_as_ValueBuffer();
}

struct UniqueSignalNotifyBuilder {
  typedef UniqueSignalNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frame_id(::flatbuffers::Offset<::flatbuffers::String> frame_id) {
    fbb_.AddOffset(UniqueSignalNotify::VT_FRAME_ID, frame_id);
  }
  void add_signal_id(::flatbuffers::Offset<::flatbuffers::String> signal_id) {
    fbb_.AddOffset(UniqueSignalNotify::VT_SIGNAL_ID, signal_id);
  }
  void add_value_type(nil::xit::fbs::ValueUnion value_type) {
    fbb_.AddElement<uint8_t>(UniqueSignalNotify::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(UniqueSignalNotify::VT_VALUE, value);
  }
  explicit UniqueSignalNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UniqueSignalNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UniqueSignalNotify>(end);
    fbb_.Required(o, UniqueSignalNotify::VT_FRAME_ID);
    fbb_.Required(o, UniqueSignalNotify::VT_SIGNAL_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<UniqueSignalNotify> CreateUniqueSignalNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> frame_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signal_id = 0,
    nil::xit::fbs::ValueUnion value_type = nil::xit::fbs::ValueUnion_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  UniqueSignalNotifyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_signal_id(signal_id);
  builder_.add_frame_id(frame_id);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UniqueSignalNotify> CreateUniqueSignalNotifyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *frame_id = nullptr,
    const char *signal_id = nullptr,
    nil::xit::fbs::ValueUnion value_type = nil::xit::fbs::ValueUnion_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  auto signal_id__ = signal_id ? _fbb.CreateString(signal_id) : 0;
  return nil::xit::fbs::CreateUniqueSignalNotify(
      _fbb,
      frame_id__,
      signal_id__,
      value_type,
      value);
}

::flatbuffers::Offset<UniqueSignalNotify> CreateUniqueSignalNotify(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TaggedSignalNotifyT : public ::flatbuffers::NativeTable {
  typedef TaggedSignalNotify TableType;
  std::string frame_id{};
  std::string tag{};
  std::string signal_id{};
  nil::xit::fbs::ValueUnionUnion value{};
};

struct TaggedSignalNotify FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TaggedSignalNotifyT NativeTableType;
  typedef TaggedSignalNotifyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_ID = 4,
    VT_TAG = 6,
    VT_SIGNAL_ID = 8,
    VT_VALUE_TYPE = 10,
    VT_VALUE = 12
  };
  const ::flatbuffers::String *frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_ID);
  }
  const ::flatbuffers::String *tag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TAG);
  }
  const ::flatbuffers::String *signal_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIGNAL_ID);
  }
  nil::xit::fbs::ValueUnion value_type() const {
    return static_cast<nil::xit::fbs::ValueUnion>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const nil::xit::fbs::ValueBoolean *value_as_ValueBoolean() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueBoolean ? static_cast<const nil::xit::fbs::ValueBoolean *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueNumber *value_as_ValueNumber() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueNumber ? static_cast<const nil::xit::fbs::ValueNumber *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueDouble *value_as_ValueDouble() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueDouble ? static_cast<const nil::xit::fbs::ValueDouble *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueString *value_as_ValueString() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueString ? static_cast<const nil::xit::fbs::ValueString *>(value()) : nullptr;
  }
  const nil::xit::fbs::ValueBuffer *value_as_ValueBuffer() const {
    return value_type() == nil::xit::fbs::ValueUnion_ValueBuffer ? static_cast<const nil::xit::fbs::ValueBuffer *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           VerifyOffsetRequired(verifier, VT_TAG) &&
           verifier.VerifyString(tag()) &&
           VerifyOffsetRequired(verifier, VT_SIGNAL_ID) &&
           verifier.VerifyString(signal_id()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueUnion(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  TaggedSignalNotifyT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TaggedSignalNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<TaggedSignalNotify> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const nil::xit::fbs::ValueBoolean *TaggedSignalNotify::value_as<nil::xit::fbs::ValueBoolean>() const {
  return value_as_ValueBoolean();
}

template<> inline const nil::xit::fbs::ValueNumber *TaggedSignalNotify::value_as<nil::xit::fbs::ValueNumber>() const {
  return value_as_ValueNumber();
}

template<> inline const nil::xit::fbs::ValueDouble *TaggedSignalNotify::value_as<nil::xit::fbs::ValueDouble>() const {
  return value_as_ValueDouble();
}

template<> inline const nil::xit::fbs::ValueString *TaggedSignalNotify::value_as<nil::xit::fbs::ValueString>() const {
  return value_as_ValueString();
}

template<> inline const nil::xit::fbs::ValueBuffer *TaggedSignalNotify::value_as<nil::xit::fbs::ValueBuffer>() const {
  return value_as_ValueBuffer();
}

struct TaggedSignalNotifyBuilder {
  typedef TaggedSignalNotify Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frame_id(::flatbuffers::Offset<::flatbuffers::String> frame_id) {
    fbb_.AddOffset(TaggedSignalNotify::VT_FRAME_ID, frame_id);
  }
  void add_tag(::flatbuffers::Offset<::flatbuffers::String> tag) {
    fbb_.AddOffset(TaggedSignalNotify::VT_TAG, tag);
  }
  void add_signal_id(::flatbuffers::Offset<::flatbuffers::String> signal_id) {
    fbb_.AddOffset(TaggedSignalNotify::VT_SIGNAL_ID, signal_id);
  }
  void add_value_type(nil::xit::fbs::ValueUnion value_type) {
    fbb_.AddElement<uint8_t>(TaggedSignalNotify::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(TaggedSignalNotify::VT_VALUE, value);
  }
  explicit TaggedSignalNotifyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TaggedSignalNotify> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TaggedSignalNotify>(end);
    fbb_.Required(o, TaggedSignalNotify::VT_FRAME_ID);
    fbb_.Required(o, TaggedSignalNotify::VT_TAG);
    fbb_.Required(o, TaggedSignalNotify::VT_SIGNAL_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<TaggedSignalNotify> CreateTaggedSignalNotify(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> frame_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tag = 0,
    ::flatbuffers::Offset<::flatbuffers::String> signal_id = 0,
    nil::xit::fbs::ValueUnion value_type = nil::xit::fbs::ValueUnion_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  TaggedSignalNotifyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_signal_id(signal_id);
  builder_.add_tag(tag);
  builder_.add_frame_id(frame_id);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TaggedSignalNotify> CreateTaggedSignalNotifyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *frame_id = nullptr,
    const char *tag = nullptr,
    const char *signal_id = nullptr,
    nil::xit::fbs::ValueUnion value_type = nil::xit::fbs::ValueUnion_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  auto tag__ = tag ? _fbb.CreateString(tag) : 0;
  auto signal_id__ = signal_id ? _fbb.CreateString(signal_id) : 0;
  return nil::xit::fbs::CreateTaggedSignalNotify(
      _fbb,
      frame_id__,
      tag__,
      signal_id__,
      value_type,
      value);
}

::flatbuffers::Offset<TaggedSignalNotify> CreateTaggedSignalNotify(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline UniqueFrameInfoRequestT *UniqueFrameInfoRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueFrameInfoRequestT>(new UniqueFrameInfoRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueFrameInfoRequest::UnPackTo(UniqueFrameInfoRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueFrameInfoRequest> UniqueFrameInfoRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueFrameInfoRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueFrameInfoRequest> CreateUniqueFrameInfoRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueFrameInfoRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueFrameInfoRequest(
      _fbb,
      _id);
}

inline TaggedFrameInfoRequestT *TaggedFrameInfoRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedFrameInfoRequestT>(new TaggedFrameInfoRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedFrameInfoRequest::UnPackTo(TaggedFrameInfoRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedFrameInfoRequest> TaggedFrameInfoRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedFrameInfoRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedFrameInfoRequest> CreateTaggedFrameInfoRequest(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedFrameInfoRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedFrameInfoRequest(
      _fbb,
      _id,
      _tag);
}

inline UniqueFrameInfoResponseT *UniqueFrameInfoResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueFrameInfoResponseT>(new UniqueFrameInfoResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueFrameInfoResponse::UnPackTo(UniqueFrameInfoResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueFrameInfoResponse> UniqueFrameInfoResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueFrameInfoResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueFrameInfoResponse> CreateUniqueFrameInfoResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameInfoResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueFrameInfoResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _value = _fbb.CreateString(_o->value);
  return nil::xit::fbs::CreateUniqueFrameInfoResponse(
      _fbb,
      _id,
      _value);
}

inline TaggedFrameInfoResponseT *TaggedFrameInfoResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedFrameInfoResponseT>(new TaggedFrameInfoResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedFrameInfoResponse::UnPackTo(TaggedFrameInfoResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedFrameInfoResponse> TaggedFrameInfoResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedFrameInfoResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedFrameInfoResponse> CreateTaggedFrameInfoResponse(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameInfoResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedFrameInfoResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  auto _value = _fbb.CreateString(_o->value);
  return nil::xit::fbs::CreateTaggedFrameInfoResponse(
      _fbb,
      _id,
      _tag,
      _value);
}

inline FileRequestT *FileRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileRequestT>(new FileRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileRequest::UnPackTo(FileRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) _o->target = _e->str(); }
}

inline ::flatbuffers::Offset<FileRequest> FileRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FileRequest> CreateFileRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FileRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FileRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _fbb.CreateString(_o->target);
  return nil::xit::fbs::CreateFileRequest(
      _fbb,
      _target);
}

inline FileAliasRequestT *FileAliasRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileAliasRequestT>(new FileAliasRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileAliasRequest::UnPackTo(FileAliasRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<FileAliasRequest> FileAliasRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileAliasRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FileAliasRequest> CreateFileAliasRequest(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FileAliasRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return nil::xit::fbs::CreateFileAliasRequest(
      _fbb);
}

inline FileInfoT *FileInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileInfoT>(new FileInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileInfo::UnPackTo(FileInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) _o->target = _e->str(); }
  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->metadata.begin()); } }
}

inline ::flatbuffers::Offset<FileInfo> FileInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FileInfo> CreateFileInfo(::flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FileInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _fbb.CreateString(_o->target);
  auto _metadata = _fbb.CreateVector(_o->metadata);
  return nil::xit::fbs::CreateFileInfo(
      _fbb,
      _target,
      _metadata);
}

inline FileResponseT *FileResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileResponseT>(new FileResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileResponse::UnPackTo(FileResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target(); if (_e) _o->target = _e->str(); }
  { auto _e = content(); if (_e) _o->content = _e->str(); }
  { auto _e = metadata(); if (_e) { _o->metadata.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->metadata.begin()); } }
}

inline ::flatbuffers::Offset<FileResponse> FileResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FileResponse> CreateFileResponse(::flatbuffers::FlatBufferBuilder &_fbb, const FileResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FileResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target = _fbb.CreateString(_o->target);
  auto _content = _fbb.CreateString(_o->content);
  auto _metadata = _fbb.CreateVector(_o->metadata);
  return nil::xit::fbs::CreateFileResponse(
      _fbb,
      _target,
      _content,
      _metadata);
}

inline FileAliasT *FileAlias::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileAliasT>(new FileAliasT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileAlias::UnPackTo(FileAliasT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<FileAlias> FileAlias::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileAlias(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FileAlias> CreateFileAlias(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FileAliasT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateString(_o->key);
  auto _value = _fbb.CreateString(_o->value);
  return nil::xit::fbs::CreateFileAlias(
      _fbb,
      _key,
      _value);
}

inline FileAliasResponseT::FileAliasResponseT(const FileAliasResponseT &o) {
  aliases.reserve(o.aliases.size());
  for (const auto &aliases_ : o.aliases) { aliases.emplace_back((aliases_) ? new nil::xit::fbs::FileAliasT(*aliases_) : nullptr); }
}

inline FileAliasResponseT &FileAliasResponseT::operator=(FileAliasResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(aliases, o.aliases);
  return *this;
}

inline FileAliasResponseT *FileAliasResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileAliasResponseT>(new FileAliasResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileAliasResponse::UnPackTo(FileAliasResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = aliases(); if (_e) { _o->aliases.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->aliases[_i]) { _e->Get(_i)->UnPackTo(_o->aliases[_i].get(), _resolver); } else { _o->aliases[_i] = std::unique_ptr<nil::xit::fbs::FileAliasT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->aliases.resize(0); } }
}

inline ::flatbuffers::Offset<FileAliasResponse> FileAliasResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileAliasResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FileAliasResponse> CreateFileAliasResponse(::flatbuffers::FlatBufferBuilder &_fbb, const FileAliasResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FileAliasResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _aliases = _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::FileAlias>> (_o->aliases.size(), [](size_t i, _VectorArgs *__va) { return CreateFileAlias(*__va->__fbb, __va->__o->aliases[i].get(), __va->__rehasher); }, &_va );
  return nil::xit::fbs::CreateFileAliasResponse(
      _fbb,
      _aliases);
}

inline FrameCacheT::FrameCacheT(const FrameCacheT &o)
      : id(o.id),
        target(o.target),
        full_target(o.full_target),
        content(o.content) {
  files.reserve(o.files.size());
  for (const auto &files_ : o.files) { files.emplace_back((files_) ? new nil::xit::fbs::FileInfoT(*files_) : nullptr); }
}

inline FrameCacheT &FrameCacheT::operator=(FrameCacheT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(target, o.target);
  std::swap(full_target, o.full_target);
  std::swap(content, o.content);
  std::swap(files, o.files);
  return *this;
}

inline FrameCacheT *FrameCache::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FrameCacheT>(new FrameCacheT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FrameCache::UnPackTo(FrameCacheT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = target(); if (_e) _o->target = _e->str(); }
  { auto _e = full_target(); if (_e) _o->full_target = _e->str(); }
  { auto _e = content(); if (_e) _o->content = _e->str(); }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->files[_i]) { _e->Get(_i)->UnPackTo(_o->files[_i].get(), _resolver); } else { _o->files[_i] = std::unique_ptr<nil::xit::fbs::FileInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->files.resize(0); } }
}

inline ::flatbuffers::Offset<FrameCache> FrameCache::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameCacheT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameCache(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FrameCache> CreateFrameCache(::flatbuffers::FlatBufferBuilder &_fbb, const FrameCacheT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FrameCacheT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _target = _fbb.CreateString(_o->target);
  auto _full_target = _fbb.CreateString(_o->full_target);
  auto _content = _fbb.CreateString(_o->content);
  auto _files = _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::FileInfo>> (_o->files.size(), [](size_t i, _VectorArgs *__va) { return CreateFileInfo(*__va->__fbb, __va->__o->files[i].get(), __va->__rehasher); }, &_va );
  return nil::xit::fbs::CreateFrameCache(
      _fbb,
      _id,
      _target,
      _full_target,
      _content,
      _files);
}

inline UniqueFrameLoadedT *UniqueFrameLoaded::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueFrameLoadedT>(new UniqueFrameLoadedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueFrameLoaded::UnPackTo(UniqueFrameLoadedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueFrameLoaded> UniqueFrameLoaded::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameLoadedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueFrameLoaded(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueFrameLoaded> CreateUniqueFrameLoaded(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameLoadedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueFrameLoadedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueFrameLoaded(
      _fbb,
      _id);
}

inline TaggedFrameLoadedT *TaggedFrameLoaded::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedFrameLoadedT>(new TaggedFrameLoadedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedFrameLoaded::UnPackTo(TaggedFrameLoadedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedFrameLoaded> TaggedFrameLoaded::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameLoadedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedFrameLoaded(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedFrameLoaded> CreateTaggedFrameLoaded(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameLoadedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedFrameLoadedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedFrameLoaded(
      _fbb,
      _id,
      _tag);
}

inline UniqueFrameSubscribeT *UniqueFrameSubscribe::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueFrameSubscribeT>(new UniqueFrameSubscribeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueFrameSubscribe::UnPackTo(UniqueFrameSubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueFrameSubscribe> UniqueFrameSubscribe::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameSubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueFrameSubscribe(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueFrameSubscribe> CreateUniqueFrameSubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameSubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueFrameSubscribeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueFrameSubscribe(
      _fbb,
      _id);
}

inline TaggedFrameSubscribeT *TaggedFrameSubscribe::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedFrameSubscribeT>(new TaggedFrameSubscribeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedFrameSubscribe::UnPackTo(TaggedFrameSubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedFrameSubscribe> TaggedFrameSubscribe::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameSubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedFrameSubscribe(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedFrameSubscribe> CreateTaggedFrameSubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameSubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedFrameSubscribeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedFrameSubscribe(
      _fbb,
      _id,
      _tag);
}

inline UniqueFrameUnsubscribeT *UniqueFrameUnsubscribe::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueFrameUnsubscribeT>(new UniqueFrameUnsubscribeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueFrameUnsubscribe::UnPackTo(UniqueFrameUnsubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueFrameUnsubscribe> UniqueFrameUnsubscribe::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameUnsubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueFrameUnsubscribe(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueFrameUnsubscribe> CreateUniqueFrameUnsubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameUnsubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueFrameUnsubscribeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueFrameUnsubscribe(
      _fbb,
      _id);
}

inline TaggedFrameUnsubscribeT *TaggedFrameUnsubscribe::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedFrameUnsubscribeT>(new TaggedFrameUnsubscribeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedFrameUnsubscribe::UnPackTo(TaggedFrameUnsubscribeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedFrameUnsubscribe> TaggedFrameUnsubscribe::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameUnsubscribeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedFrameUnsubscribe(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedFrameUnsubscribe> CreateTaggedFrameUnsubscribe(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameUnsubscribeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedFrameUnsubscribeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedFrameUnsubscribe(
      _fbb,
      _id,
      _tag);
}

inline UniqueFrameNotifyT *UniqueFrameNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueFrameNotifyT>(new UniqueFrameNotifyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueFrameNotify::UnPackTo(UniqueFrameNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueFrameNotify> UniqueFrameNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueFrameNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueFrameNotify> CreateUniqueFrameNotify(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueFrameNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueFrameNotifyT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueFrameNotify(
      _fbb,
      _id);
}

inline TaggedFrameNotifyT *TaggedFrameNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedFrameNotifyT>(new TaggedFrameNotifyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedFrameNotify::UnPackTo(TaggedFrameNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedFrameNotify> TaggedFrameNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedFrameNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedFrameNotify> CreateTaggedFrameNotify(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedFrameNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedFrameNotifyT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedFrameNotify(
      _fbb,
      _id,
      _tag);
}

inline ValueBooleanT *ValueBoolean::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ValueBooleanT>(new ValueBooleanT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ValueBoolean::UnPackTo(ValueBooleanT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline ::flatbuffers::Offset<ValueBoolean> ValueBoolean::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBooleanT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValueBoolean(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ValueBoolean> CreateValueBoolean(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBooleanT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValueBooleanT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return nil::xit::fbs::CreateValueBoolean(
      _fbb,
      _value);
}

inline ValueNumberT *ValueNumber::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ValueNumberT>(new ValueNumberT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ValueNumber::UnPackTo(ValueNumberT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline ::flatbuffers::Offset<ValueNumber> ValueNumber::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueNumberT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValueNumber(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ValueNumber> CreateValueNumber(::flatbuffers::FlatBufferBuilder &_fbb, const ValueNumberT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValueNumberT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return nil::xit::fbs::CreateValueNumber(
      _fbb,
      _value);
}

inline ValueDoubleT *ValueDouble::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ValueDoubleT>(new ValueDoubleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ValueDouble::UnPackTo(ValueDoubleT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); _o->value = _e; }
}

inline ::flatbuffers::Offset<ValueDouble> ValueDouble::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueDoubleT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValueDouble(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ValueDouble> CreateValueDouble(::flatbuffers::FlatBufferBuilder &_fbb, const ValueDoubleT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValueDoubleT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value;
  return nil::xit::fbs::CreateValueDouble(
      _fbb,
      _value);
}

inline ValueStringT *ValueString::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ValueStringT>(new ValueStringT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ValueString::UnPackTo(ValueStringT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline ::flatbuffers::Offset<ValueString> ValueString::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueStringT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValueString(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ValueString> CreateValueString(::flatbuffers::FlatBufferBuilder &_fbb, const ValueStringT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValueStringT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return nil::xit::fbs::CreateValueString(
      _fbb,
      _value);
}

inline ValueBufferT *ValueBuffer::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ValueBufferT>(new ValueBufferT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ValueBuffer::UnPackTo(ValueBufferT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) { _o->value.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->value.begin()); } }
}

inline ::flatbuffers::Offset<ValueBuffer> ValueBuffer::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBufferT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValueBuffer(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ValueBuffer> CreateValueBuffer(::flatbuffers::FlatBufferBuilder &_fbb, const ValueBufferT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValueBufferT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.size() ? _fbb.CreateVector(_o->value) : 0;
  return nil::xit::fbs::CreateValueBuffer(
      _fbb,
      _value);
}

inline ValueT *Value::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ValueT>(new ValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Value::UnPackTo(ValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = nil::xit::fbs::ValueUnionUnion::UnPack(_e, value_type(), _resolver); }
}

inline ::flatbuffers::Offset<Value> Value::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Value> CreateValue(::flatbuffers::FlatBufferBuilder &_fbb, const ValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return nil::xit::fbs::CreateValue(
      _fbb,
      _id,
      _value_type,
      _value);
}

inline UniqueValueRequestT *UniqueValueRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueValueRequestT>(new UniqueValueRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueValueRequest::UnPackTo(UniqueValueRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueValueRequest> UniqueValueRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueValueRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueValueRequest> CreateUniqueValueRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueValueRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueValueRequest(
      _fbb,
      _id);
}

inline TaggedValueRequestT *TaggedValueRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedValueRequestT>(new TaggedValueRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedValueRequest::UnPackTo(TaggedValueRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedValueRequest> TaggedValueRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedValueRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedValueRequest> CreateTaggedValueRequest(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedValueRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedValueRequest(
      _fbb,
      _id,
      _tag);
}

inline UniqueValueResponseT::UniqueValueResponseT(const UniqueValueResponseT &o)
      : id(o.id) {
  values.reserve(o.values.size());
  for (const auto &values_ : o.values) { values.emplace_back((values_) ? new nil::xit::fbs::ValueT(*values_) : nullptr); }
}

inline UniqueValueResponseT &UniqueValueResponseT::operator=(UniqueValueResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(values, o.values);
  return *this;
}

inline UniqueValueResponseT *UniqueValueResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueValueResponseT>(new UniqueValueResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueValueResponse::UnPackTo(UniqueValueResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->values[_i]) { _e->Get(_i)->UnPackTo(_o->values[_i].get(), _resolver); } else { _o->values[_i] = std::unique_ptr<nil::xit::fbs::ValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<UniqueValueResponse> UniqueValueResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueValueResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueValueResponse> CreateUniqueValueResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueValueResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _values = _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Value>> (_o->values.size(), [](size_t i, _VectorArgs *__va) { return CreateValue(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher); }, &_va );
  return nil::xit::fbs::CreateUniqueValueResponse(
      _fbb,
      _id,
      _values);
}

inline TaggedValueResponseT::TaggedValueResponseT(const TaggedValueResponseT &o)
      : id(o.id),
        tag(o.tag) {
  values.reserve(o.values.size());
  for (const auto &values_ : o.values) { values.emplace_back((values_) ? new nil::xit::fbs::ValueT(*values_) : nullptr); }
}

inline TaggedValueResponseT &TaggedValueResponseT::operator=(TaggedValueResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(tag, o.tag);
  std::swap(values, o.values);
  return *this;
}

inline TaggedValueResponseT *TaggedValueResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedValueResponseT>(new TaggedValueResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedValueResponse::UnPackTo(TaggedValueResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = values(); if (_e) { _o->values.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->values[_i]) { _e->Get(_i)->UnPackTo(_o->values[_i].get(), _resolver); } else { _o->values[_i] = std::unique_ptr<nil::xit::fbs::ValueT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->values.resize(0); } }
}

inline ::flatbuffers::Offset<TaggedValueResponse> TaggedValueResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedValueResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedValueResponse> CreateTaggedValueResponse(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedValueResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  auto _values = _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Value>> (_o->values.size(), [](size_t i, _VectorArgs *__va) { return CreateValue(*__va->__fbb, __va->__o->values[i].get(), __va->__rehasher); }, &_va );
  return nil::xit::fbs::CreateTaggedValueResponse(
      _fbb,
      _id,
      _tag,
      _values);
}

inline UniqueValueUpdateT::UniqueValueUpdateT(const UniqueValueUpdateT &o)
      : id(o.id),
        value((o.value) ? new nil::xit::fbs::ValueT(*o.value) : nullptr) {
}

inline UniqueValueUpdateT &UniqueValueUpdateT::operator=(UniqueValueUpdateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(value, o.value);
  return *this;
}

inline UniqueValueUpdateT *UniqueValueUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueValueUpdateT>(new UniqueValueUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueValueUpdate::UnPackTo(UniqueValueUpdateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = value(); if (_e) { if(_o->value) { _e->UnPackTo(_o->value.get(), _resolver); } else { _o->value = std::unique_ptr<nil::xit::fbs::ValueT>(_e->UnPack(_resolver)); } } else if (_o->value) { _o->value.reset(); } }
}

inline ::flatbuffers::Offset<UniqueValueUpdate> UniqueValueUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueUpdateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueValueUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueValueUpdate> CreateUniqueValueUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueValueUpdateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueValueUpdateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _value = _o->value ? CreateValue(_fbb, _o->value.get(), _rehasher) : 0;
  return nil::xit::fbs::CreateUniqueValueUpdate(
      _fbb,
      _id,
      _value);
}

inline TaggedValueUpdateT::TaggedValueUpdateT(const TaggedValueUpdateT &o)
      : id(o.id),
        tag(o.tag),
        value((o.value) ? new nil::xit::fbs::ValueT(*o.value) : nullptr) {
}

inline TaggedValueUpdateT &TaggedValueUpdateT::operator=(TaggedValueUpdateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(tag, o.tag);
  std::swap(value, o.value);
  return *this;
}

inline TaggedValueUpdateT *TaggedValueUpdate::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedValueUpdateT>(new TaggedValueUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedValueUpdate::UnPackTo(TaggedValueUpdateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = value(); if (_e) { if(_o->value) { _e->UnPackTo(_o->value.get(), _resolver); } else { _o->value = std::unique_ptr<nil::xit::fbs::ValueT>(_e->UnPack(_resolver)); } } else if (_o->value) { _o->value.reset(); } }
}

inline ::flatbuffers::Offset<TaggedValueUpdate> TaggedValueUpdate::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueUpdateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedValueUpdate(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedValueUpdate> CreateTaggedValueUpdate(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedValueUpdateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedValueUpdateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  auto _value = _o->value ? CreateValue(_fbb, _o->value.get(), _rehasher) : 0;
  return nil::xit::fbs::CreateTaggedValueUpdate(
      _fbb,
      _id,
      _tag,
      _value);
}

inline SignalT *Signal::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalT>(new SignalT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Signal::UnPackTo(SignalT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = type(); _o->type = _e; }
}

inline ::flatbuffers::Offset<Signal> Signal::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SignalT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignal(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Signal> CreateSignal(::flatbuffers::FlatBufferBuilder &_fbb, const SignalT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SignalT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _type = _o->type;
  return nil::xit::fbs::CreateSignal(
      _fbb,
      _id,
      _type);
}

inline UniqueSignalRequestT *UniqueSignalRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueSignalRequestT>(new UniqueSignalRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueSignalRequest::UnPackTo(UniqueSignalRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
}

inline ::flatbuffers::Offset<UniqueSignalRequest> UniqueSignalRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueSignalRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueSignalRequest> CreateUniqueSignalRequest(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueSignalRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  return nil::xit::fbs::CreateUniqueSignalRequest(
      _fbb,
      _id);
}

inline TaggedSignalRequestT *TaggedSignalRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedSignalRequestT>(new TaggedSignalRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedSignalRequest::UnPackTo(TaggedSignalRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
}

inline ::flatbuffers::Offset<TaggedSignalRequest> TaggedSignalRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedSignalRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedSignalRequest> CreateTaggedSignalRequest(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedSignalRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  return nil::xit::fbs::CreateTaggedSignalRequest(
      _fbb,
      _id,
      _tag);
}

inline UniqueSignalResponseT::UniqueSignalResponseT(const UniqueSignalResponseT &o)
      : id(o.id) {
  signals.reserve(o.signals.size());
  for (const auto &signals_ : o.signals) { signals.emplace_back((signals_) ? new nil::xit::fbs::SignalT(*signals_) : nullptr); }
}

inline UniqueSignalResponseT &UniqueSignalResponseT::operator=(UniqueSignalResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(signals, o.signals);
  return *this;
}

inline UniqueSignalResponseT *UniqueSignalResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueSignalResponseT>(new UniqueSignalResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueSignalResponse::UnPackTo(UniqueSignalResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = signals(); if (_e) { _o->signals.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->signals[_i]) { _e->Get(_i)->UnPackTo(_o->signals[_i].get(), _resolver); } else { _o->signals[_i] = std::unique_ptr<nil::xit::fbs::SignalT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->signals.resize(0); } }
}

inline ::flatbuffers::Offset<UniqueSignalResponse> UniqueSignalResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueSignalResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueSignalResponse> CreateUniqueSignalResponse(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueSignalResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _signals = _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Signal>> (_o->signals.size(), [](size_t i, _VectorArgs *__va) { return CreateSignal(*__va->__fbb, __va->__o->signals[i].get(), __va->__rehasher); }, &_va );
  return nil::xit::fbs::CreateUniqueSignalResponse(
      _fbb,
      _id,
      _signals);
}

inline TaggedSignalResponseT::TaggedSignalResponseT(const TaggedSignalResponseT &o)
      : id(o.id),
        tag(o.tag) {
  signals.reserve(o.signals.size());
  for (const auto &signals_ : o.signals) { signals.emplace_back((signals_) ? new nil::xit::fbs::SignalT(*signals_) : nullptr); }
}

inline TaggedSignalResponseT &TaggedSignalResponseT::operator=(TaggedSignalResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(id, o.id);
  std::swap(tag, o.tag);
  std::swap(signals, o.signals);
  return *this;
}

inline TaggedSignalResponseT *TaggedSignalResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedSignalResponseT>(new TaggedSignalResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedSignalResponse::UnPackTo(TaggedSignalResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = signals(); if (_e) { _o->signals.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->signals[_i]) { _e->Get(_i)->UnPackTo(_o->signals[_i].get(), _resolver); } else { _o->signals[_i] = std::unique_ptr<nil::xit::fbs::SignalT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->signals.resize(0); } }
}

inline ::flatbuffers::Offset<TaggedSignalResponse> TaggedSignalResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedSignalResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedSignalResponse> CreateTaggedSignalResponse(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedSignalResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _tag = _fbb.CreateString(_o->tag);
  auto _signals = _fbb.CreateVector<::flatbuffers::Offset<nil::xit::fbs::Signal>> (_o->signals.size(), [](size_t i, _VectorArgs *__va) { return CreateSignal(*__va->__fbb, __va->__o->signals[i].get(), __va->__rehasher); }, &_va );
  return nil::xit::fbs::CreateTaggedSignalResponse(
      _fbb,
      _id,
      _tag,
      _signals);
}

inline UniqueSignalNotifyT *UniqueSignalNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UniqueSignalNotifyT>(new UniqueSignalNotifyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UniqueSignalNotify::UnPackTo(UniqueSignalNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
  { auto _e = signal_id(); if (_e) _o->signal_id = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = nil::xit::fbs::ValueUnionUnion::UnPack(_e, value_type(), _resolver); }
}

inline ::flatbuffers::Offset<UniqueSignalNotify> UniqueSignalNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUniqueSignalNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<UniqueSignalNotify> CreateUniqueSignalNotify(::flatbuffers::FlatBufferBuilder &_fbb, const UniqueSignalNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const UniqueSignalNotifyT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame_id = _fbb.CreateString(_o->frame_id);
  auto _signal_id = _fbb.CreateString(_o->signal_id);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return nil::xit::fbs::CreateUniqueSignalNotify(
      _fbb,
      _frame_id,
      _signal_id,
      _value_type,
      _value);
}

inline TaggedSignalNotifyT *TaggedSignalNotify::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TaggedSignalNotifyT>(new TaggedSignalNotifyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TaggedSignalNotify::UnPackTo(TaggedSignalNotifyT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
  { auto _e = tag(); if (_e) _o->tag = _e->str(); }
  { auto _e = signal_id(); if (_e) _o->signal_id = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = nil::xit::fbs::ValueUnionUnion::UnPack(_e, value_type(), _resolver); }
}

inline ::flatbuffers::Offset<TaggedSignalNotify> TaggedSignalNotify::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalNotifyT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTaggedSignalNotify(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<TaggedSignalNotify> CreateTaggedSignalNotify(::flatbuffers::FlatBufferBuilder &_fbb, const TaggedSignalNotifyT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TaggedSignalNotifyT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame_id = _fbb.CreateString(_o->frame_id);
  auto _tag = _fbb.CreateString(_o->tag);
  auto _signal_id = _fbb.CreateString(_o->signal_id);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return nil::xit::fbs::CreateTaggedSignalNotify(
      _fbb,
      _frame_id,
      _tag,
      _signal_id,
      _value_type,
      _value);
}

inline bool VerifyValueUnion(::flatbuffers::Verifier &verifier, const void *obj, ValueUnion type) {
  switch (type) {
    case ValueUnion_NONE: {
      return true;
    }
    case ValueUnion_ValueBoolean: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueBoolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion_ValueNumber: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueNumber *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion_ValueDouble: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion_ValueString: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueUnion_ValueBuffer: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueBuffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueUnion(
        verifier,  values->Get(i), types->GetEnum<ValueUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ValueUnionUnion::UnPack(const void *obj, ValueUnion type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ValueUnion_ValueBoolean: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueBoolean *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueUnion_ValueNumber: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueNumber *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueUnion_ValueDouble: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueDouble *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueUnion_ValueString: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueString *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueUnion_ValueBuffer: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueBuffer *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ValueUnionUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ValueUnion_ValueBoolean: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueBooleanT *>(value);
      return CreateValueBoolean(_fbb, ptr, _rehasher).Union();
    }
    case ValueUnion_ValueNumber: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueNumberT *>(value);
      return CreateValueNumber(_fbb, ptr, _rehasher).Union();
    }
    case ValueUnion_ValueDouble: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueDoubleT *>(value);
      return CreateValueDouble(_fbb, ptr, _rehasher).Union();
    }
    case ValueUnion_ValueString: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueStringT *>(value);
      return CreateValueString(_fbb, ptr, _rehasher).Union();
    }
    case ValueUnion_ValueBuffer: {
      auto ptr = reinterpret_cast<const nil::xit::fbs::ValueBufferT *>(value);
      return CreateValueBuffer(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ValueUnionUnion::ValueUnionUnion(const ValueUnionUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ValueUnion_ValueBoolean: {
      value = new nil::xit::fbs::ValueBooleanT(*reinterpret_cast<nil::xit::fbs::ValueBooleanT *>(u.value));
      break;
    }
    case ValueUnion_ValueNumber: {
      value = new nil::xit::fbs::ValueNumberT(*reinterpret_cast<nil::xit::fbs::ValueNumberT *>(u.value));
      break;
    }
    case ValueUnion_ValueDouble: {
      value = new nil::xit::fbs::ValueDoubleT(*reinterpret_cast<nil::xit::fbs::ValueDoubleT *>(u.value));
      break;
    }
    case ValueUnion_ValueString: {
      value = new nil::xit::fbs::ValueStringT(*reinterpret_cast<nil::xit::fbs::ValueStringT *>(u.value));
      break;
    }
    case ValueUnion_ValueBuffer: {
      value = new nil::xit::fbs::ValueBufferT(*reinterpret_cast<nil::xit::fbs::ValueBufferT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ValueUnionUnion::Reset() {
  switch (type) {
    case ValueUnion_ValueBoolean: {
      auto ptr = reinterpret_cast<nil::xit::fbs::ValueBooleanT *>(value);
      delete ptr;
      break;
    }
    case ValueUnion_ValueNumber: {
      auto ptr = reinterpret_cast<nil::xit::fbs::ValueNumberT *>(value);
      delete ptr;
      break;
    }
    case ValueUnion_ValueDouble: {
      auto ptr = reinterpret_cast<nil::xit::fbs::ValueDoubleT *>(value);
      delete ptr;
      break;
    }
    case ValueUnion_ValueString: {
      auto ptr = reinterpret_cast<nil::xit::fbs::ValueStringT *>(value);
      delete ptr;
      break;
    }
    case ValueUnion_ValueBuffer: {
      auto ptr = reinterpret_cast<nil::xit::fbs::ValueBufferT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ValueUnion_NONE;
}

}  // namespace fbs
}  // namespace xit
}  // namespace nil

#endif  // FLATBUFFERS_GENERATED_MESSAGE_NIL_XIT_FBS_H_
